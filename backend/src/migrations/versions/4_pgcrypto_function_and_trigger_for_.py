"""Pgcrypto, function and trigger for document_number

Revision ID: 9854de4134de
Revises: 9b504bd55bdb
Create Date: 2025-04-21 17:40:20.727287

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from alembic_utils.pg_extension import PGExtension
from sqlalchemy import text as sql_text
from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from alembic_utils.pg_trigger import PGTrigger
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision: str = '4'
down_revision: Union[str, None] = '3'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    public_pgcrypto = PGExtension(
        schema="public",
        signature="pgcrypto"
    )
    op.create_entity(public_pgcrypto)

    public_increment_document_number = PGFunction(
        schema="public",
        signature="increment_document_number()",
        definition="RETURNS trigger AS\n    $$\n    DECLARE\n        current_year INTEGER := EXTRACT(YEAR FROM NEW.document_datetime);\n        new_counter INTEGER;\n    BEGIN\n        -- вставляем новую строку в счётчик (стартуя с 1) или увеличиваем существующий\n        INSERT INTO document_number_counters (id, document_type_id, year, counter)\n        VALUES (gen_random_uuid(), NEW.document_type_id, current_year, 1)\n        ON CONFLICT (document_type_id, year)\n        DO UPDATE SET counter = document_number_counters.counter + 1\n        RETURNING counter INTO new_counter;\n\n        -- проставляем в новый документ номер и шаблонное имя\n        NEW.document_number := new_counter;\n    \n        IF NEW.name IS NULL OR NEW.name = '' THEN\n            NEW.name := format(\n                'base_recipe_%s_%s',\n                lpad(new_counter::TEXT, 3, '0'),\n                current_year\n            );\n        END IF;\n\n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql"
    )
    op.create_entity(public_increment_document_number)

    public_base_recipes_set_document_number = PGTrigger(
        schema="public",
        signature="set_document_number_base_recipes",
        on_entity="public.base_recipes",
        is_constraint=False,
        definition='BEFORE INSERT ON base_recipes\n    FOR EACH ROW\n    EXECUTE FUNCTION increment_document_number()'
    )
    op.create_entity(public_base_recipes_set_document_number)

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    public_base_recipes_set_document_number = PGTrigger(
        schema="public",
        signature="set_document_number_base_recipes",
        on_entity="public.base_recipes",
        is_constraint=False,
        definition='BEFORE INSERT ON base_recipes\n    FOR EACH ROW\n    EXECUTE FUNCTION increment_document_number()'
    )
    op.drop_entity(public_base_recipes_set_document_number)

    public_increment_document_number = PGFunction(
        schema="public",
        signature="increment_document_number()",
        definition="RETURNS trigger AS\n    $$\n    DECLARE\n        current_year INTEGER := EXTRACT(YEAR FROM NEW.document_datetime);\n        new_counter INTEGER;\n    BEGIN\n        -- вставляем новую строку в счётчик (стартуя с 1) или увеличиваем существующий\n        INSERT INTO document_number_counters (id, document_type_id, year, counter)\n        VALUES (gen_random_uuid(), NEW.document_type_id, current_year, 1)\n        ON CONFLICT (document_type_id, year)\n        DO UPDATE SET counter = document_number_counters.counter + 1\n        RETURNING counter INTO new_counter;\n\n        -- проставляем в новый документ номер и шаблонное имя\n        NEW.document_number := new_counter;\n    \n        IF NEW.name IS NULL OR NEW.name = '' THEN\n            NEW.name := format(\n                'base_recipe_%s_%s',\n                lpad(new_counter::TEXT, 3, '0'),\n                current_year\n            );\n        END IF;\n\n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql"
    )
    op.drop_entity(public_increment_document_number)

    public_pgcrypto = PGExtension(
        schema="public",
        signature="pgcrypto"
    )
    op.drop_entity(public_pgcrypto)

    # ### end Alembic commands ###
